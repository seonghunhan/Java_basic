처음 시작할 때 
https://medium.com/duckuism/intellij%EC%97%90%EC%84%9C-eclipse-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-import-%ED%95%98%EA%B8%B0-9e222b5548db
참고해서 IDE에서 인텔리제이 와 이클립스 다루기(이거는 2019버전 인텔리제이)

- 인텔리제이를 사용한 이유
- 이클립스 파일을 인텔리제이에 가져온 이유
- 인텔리제이와 이클립스의 차이

https://www.jetbrains.com/help/idea/migrating-from-eclipse-to-intellij-idea.html#user_interface
인텔리제이 사이트에서 추천방법

https://willbesoon.tistory.com/191
이걸로 해결 (너카톡 본게임부터 시작)

배열

- 인덱스를 이용해서 자료형이 같은 데이터를 관리
- 배열을 구성하는 데이터의 자료형에 따라서 배열의 메모리 크기가 결정


- 배열도 변수와 마찬가지로 선언과 초기화 과정을 거쳐 사용
(배열 사용 후 초기화)
(배열 선언과 동시에 초기화)

- 배열 선언시 안에있는 변수의 타입은 미리 선언한걸로 넣어줘야함
- new라는 연산자를 이용해서 배열의 크기를 선언

위에 할 때 배열강의노트 밑에꺼 ㄱㄱ
(배열 선언 후 초기화)
public class helloworld {
    public static void main(String[] args) {

        int[] arr1 = new int[5]; // 배열 선언 단계
        arr1[0] = 100;
        arr1[1] = 200;
        arr1[2] = 300;
        arr1[3] = 400;
        arr1[4] = 500;

        System.out.println("arr[0] : " + arr1[0]);
        System.out.println("arr[1] : " + arr1[1]);
        System.out.println("arr[2] : " + arr1[2]);
    }
}

->
arr[0] : 100
arr[1] : 200
arr[2] : 300

(배열 선언과 동시에 초기화)
- 중괄호 사용 유의

public class helloworld {
    public static void main(String[] args) {

        int[] arr2 = {10, 20, 30}; // 배열 선언 단계

        System.out.println("arr[0] : " + arr2[0]);
        System.out.println("arr[1] : " + arr2[1]);
        System.out.println("arr[2] : " + arr2[2]);
    }
}


-> 
arr[0] : 10
arr[0] : 20
arr[0] : 30

* 어떤 언어는 배열의 크기를 동적으로 줄였다 늘렸다 하는 반면에 자바는 한번 선언할 때 크기가 정해지면 바뀔 수 없다
* 

---------------------
배열과메모리 강의노트 3번째장

배열 i(변수)의 주소는 첫번째 인덱스(10, i[0])의 메모리주소가 들어간다


배열 길이 함수부터 레퍼런스까지 강의노트4번째장 스샷 ㄱ

- 배열을 복사할 때 값들은 복사되지만 메모리는 같지 않다
- 배열1,2는 같기때문에 레퍼런스가 같음

다차원배열
-> 2차원까지는 사용하지만 3차원부터는 메모리를 많이 차지하기 때문에 잘 사용하지 않는다


-------------------------------------------------------

조건문 시작!!!!

양자택일 (주로 if)
다자택일 (주로 switch)

if(조건식)
조건문이 true일경우 실행
else if를 통해 다자택일도 가능


switch
비교대상이 되는 결과값과 선택사항이 많을 경우 주로 사용한다

위에꺼할때 인텔리제이 if클래스 실행

-----------------------------------------------------------
for, while, do while 시작!!!!


for (지역변수 ; 조건문 ; 증감){
	실행문
}

for문은 안에서 지역변수 i를 만들고 사용하지만
while은 밖에서 변수를 사용한다
- 조건문이 true이면 반복

do while은 조건 결과에 상관없이 최초한번은 무조건 실행

반복문 강의노트 복붙 ㄱㄱ

인텔리제이 forwhile도 ㄱㄱ



-----------------------------------------------------------------
객체 지향 프로그래밍이란???

프로그램에서의 객체는 눈에 보이지 않지만 하나의 기능들을 객체라고 부른다

객체를 만들기위한 틀을 클래스라고 한다
개발자들은 클래스만 만들고 필요에 따라 클래스를 뽑아 내는것
사용하지 않는 객체(누구와도 연동되지 않는)는 GC가(가비지 컬렉터) 회수한다
3페이지 파란 그랜저가 클래스임

------------------------------------------------------------------

클래스 제작과 객체 생성

클래스는 속성(멤버변수)와 기능(메서드) == 함수로 구성된다.


객체지향 프로그램을 만들어 놓으면 모듈화하여 다른곳에서 쉽게 사용할 수 있음

public 은 접근제한자인데 나중에 ㄱㄱ함

void는 반환값이 없다는것
반환값이 있고 그게 string형이다 그럼 메서드 앞에 string써야함
그리고 return으로 "~~~" 처럼 string을 써줘야함

외부에서 이 클래스를 이용해서 객체를 만들때 (스샷에 왼쪽이 객체를 만드는과정)(오른쪽이 클래스)
가장 먼저 호출받는게 생성자이고
생성자는 클래스와 이름이 같고, 반환형이 없다
생성자는 여러개 만들수도 있다
빈공간으로 놔두기도 한다

객체 3번째장 볼때 너카톡에 스샷찍어둔거 ㄱㄱ
new가 객체를 생성할 때 사용하는 명령어

두번째 스샷은 객체를 생성할때 파라메터도 주는것
그리고 적절한 생성자에 알아서 들어간다


---------------------------------------------------------------------

메서드

첫번 째 장

접근자 : 이 메서드의 접근을 어떻게하면 허용할지 안할지 결정한다
반환형 : 결과물을 호출부쪽으로 반환하는 것
	void는 반환값이 없다는 것
메서드 이름  : camel기법으로 첫문자는 소문자 그다음은 대문자로 표기
		동사를 먼저쓰고 다음은 명사로 쓰기



두번 째 장
필요시에만 사용한다


세번 째 장
중복메서드(같은 이름의 메서드)는 허용하지만 매개변수의 타입에서 차이가 있어야한다.


네번 째 장
접근자
public 외부에서 접근가능
private는 외부에서 접근 불가능하고 내부에서만 사용 가능


 
--------------------------------------------
객체와 메모리

첫번 째 장
객체는 메모리에서 동적으로 생성되고, 객체가 더 이상 필요 없게 되면 Gabage Collector가 삭제한다.

ObjectEx obj1 = new ObjectEx()
여기서는 obj1은 new라는 명령어를 통해 만든 객체 ObjectEx()를 가르키는 레퍼런스이다.
이거 정리할때 obj1옆에 거기는 데이터타입이긴 한데 뭔지 좀 알아보기

객체를 new라는 명령어를 통해 obj를 생성한다
ChildClass child(여기서 child는 레퍼런스이다(obj인 객체를 가르키는주소)) = new ChildClass()
위와 같은말임

obj를 가르키다가 쓸모가 없으면 노란색 obj처럼 레퍼런스가 없는 obj가 된다
(가비지 컬렉터가 관계가 안맺혀있는 obj는 쓸모없는 obj라고 판단하고 수거해간다)


두번 째 장
객체들이 같은 클래스를 선언하더라도 객체들의 레퍼런스는 엄연히 다르게 할당받는다


세번 째 장

네번 째 장
객체에 null을 대입하면 레퍼런스와 객체와의 관계가 끊기고 추후에 가비지컬렉터가 수거해간다
그러면 더이상 객체의 메서드와 속성을 접근할 수 없다.

-----------------------------------------------------
생성자와 소멸자 그리고 this 키워드

객체가 생성할때 생성하는 생성자가 있으면 GC가 호출할때 소멸시키는 소멸자도 있다

첫번째 장
클래스가 객체로 선언될 때 생성자를 먼저 호출하는데 만약 생성자가 없다면
컴파일 시점에 자동으로 만들어놔서 객체가 정상적으로 선언될 수 있다.

두번째 장

세번째 장
obj4에 두번 객체를 선언할경우 첫번째 객체와의 관계는 끊기는데,
finaize는 저런게 있다라고만 알고 넘어가기
객체가 소멸될 때 선언된다

나중에 알아서 gc가 제거하지만
System.gc()메서드를 사용하면
좀 더 빨리 해줄래?라고 요청하는것 (그렇다고 바로 GC가 작동하지는 않는다)


네번째 장
카톡 스샷 ㄱㄱ

-----------------------------------------------------
패키지와 static

첫번째 장

패키지는 클래스를 효율적으로 관리하기 위함

패키지 이름은 개발자 마음대로 정한다
일반적으로 첫번째 장에 따라 작명한다

클래스를 만들때 가장 상단에 그 파일이 소속되어있는 패키지를 적는다
ex) 
package com.java.employee;

public class Employee {

}

반대로 다른 패키지에있는 클래스를 객체로 선언할 때는
상단에 import로 해당 클래스의 패키지를 명시해주고 객체를 선언한다
ex)
package com.java.employee;

import com.java.dailyJournal.DailyJournal;
(import com.java.dailyJournal.*; 이렇게 하면 dailyJournal패키지 안에 클래스를 모두 import한것)

public class Employee {
	
	DailyJournal journal = new DailyJournal();
	
}


세번 째 장
static 카톡스샷 ㄱㄱ
다같이 공유하면서 쓰는 변수다 라고 생각하기

EmployeeBank 클래스에 static으로 mount라는 변수를 선언했고 
왼쪽 메인함수에서 parkBank, leeBank로 객체를 선언하고 mount를 둘 다 이용할때
공유가 가능하다 
기존에 박찬호가 100을 저축하고 이승엽이 300을 저축하니까
amount는 400이 나온것
근데 너무 많이 static으로 처리하면 메모리에 부담되니깐 적절하게 사용하기
-------------------------------------------------------
데이터 은닉
데이터의 속성(public같은거)으로 인하여 외부의 변질을 막기 위해서 사용
그래서 보통 private로 만들어서 외부로부터 변질되지 않게 사용함


첫번 째 장
위의 내용 ㄱㄱ

두번 째 장
private로 설정하면 외부에서 영영 접근이 불가능하니깐
그것을 메서드로 통해서 접근할 수 있게 만드는 것

이거 자바공부폴더 ㄱㄱ
1번째 사진에서는 처음 private로 선언된 변수에 최초 입력을 하는경우인거고

그런 private로 선언된 변수를 바꾸고 싶을때 set을 이용해서 외부에서 Doris로 바꾸는 과정을 뜻함

------------------------------------
상속

상위 클래스로부터 특정한 속성과 기능을 상속받는다

첫번 째 장

두번 째 장
상속을 하는 이유

세번 째 장
상속 구현하는 방법 (상속폴더 첫번째 캡쳐참고) (extends 이용)
childclass에서는 cfildFun과 상위클래스의 parentFun메서드까지 이용할 수 있다

결과물을 보면 ChildClass constructor(생성자)가 실행되기전에 상위 클래스의 ParentClass constructor가 실행되었음
이는 상속받는 클래스보다 상위 클래스가 먼저 실행된다는것을 의미한다

자바언어에서는 상속을할때 단일상속만 지원한다.
상속은 객체지향에서 나온 기법인데, 다른언어에서는 다중상속을 지원하기도 한다
예를 들면
ChildClass extend 옆에 여러개의 클래스를 명시하면 다중상속임
한 클래스 뿐 아니라 여러 클래스에서 상속을 받는 것!

네번 째 장
상위 클래스의 모든 자원을 이용할 수 있지만, private 접근자의 속성과 메서드는 사용할 수 없다.

다이어그램을 만들 때 아래(아들)에서 위(부모)쪽으로 실선 화살표로 만든다


------------------------------
상속 특징

위는 상속의 기본 개념 및 구현이였고 여기는 상속에 대해 좀 더 자세히 ㄱㄱ

첫번째 장
상위 클래스의 있는 기능을 재정의해서 사용하는 것을 메서드 오버라이드라고 한다
ChildClass에서 ParentClass의 메서드를 이용할 때 makeJJajang을 오버라이드 하면서
more dilecious가 붙여서 나온것
그리고 위에 @Override를 붙여주는게 약속

두번째 장
데이터 타입
객체를 선언할때

A b = new A() 에서 첫번째 A가 class에서 데이터타입이라고 정의함
그럼 배열을 이용할 수 있음 -> 객체 타입이 다 똑같기 때문


폴더 안에 사진(두번째캡쳐)에서 Mainclass의 ParentClass[]가 여기 객체의 타입이 되는 것!

네번째장

this는 내 객체안의 변수를 가르키고 super를 이용하면 최상위클래스의 변수를 가르킨다.

--------------------------------------
내부 클래스와 익명 클래스

첫번 째 장

내부 클래스는 클래스 안에 또 다른 클래스를 선언하는 것
보통은 클래스안에 생성자 다음 메서드를 표기하는데 여기서는 클래스를 한번 더 선언하는 것
두 클래스의 멤버에 쉽게 접근할 수 있다
근데 로직이 복잡해 보여서 실무에서는 잘 사용하지 않는다.


두번 째 장
익명클래스는 인터페이스나 추상클래스에서 주로 사용한다.

폴더에 네번째캡쳐ㄱㄱㄱㄱ

-------------------------------------------------------
인터페이스
클래스와 외형으로는 비슷하지만 클래스처럼 객체를 생성한다든지 메서드를 호출해서 기능을 수행하거나 할 수 없다
인터페이스를 사용한다면 좀 더 구조가 단단하고 세련된 코드를 짤 수 있다.
객체가 다양한 자료형(타입)을 가질 수 있기에 인터페이스를 사용한다


첫번째장
클래스에서 인터페이스를 구현하는 과정을 거친다.
그리고 클래스에서 객체를 생성하는 과정을 거친다



세번째장 (인터페이스 폴더 첫번 째 사진)
애초에 src에서 new로 생성할 때 class가 아닌 Interface가 따로 있음
Interface에서는 매서드를 선언만할 수 있고 정의할수는 없음
그래서 Interface는 작업명세서라고 부르기도 한다
원래는 public void funA()하고 중괄호 {
} 여기에 정의를하는데 Interface에서는 그런것을 할 수 없다.
그러면 선언한 메서드는 누가 구현을하느냐
인터페이스를 구현해내는 클래스에서 새롭게 정의를 내려서 사용한다.

클래스는 다중상속을 못하지만 인터페이스는 한번에 할 수 있다.(Implements이용)

MainClass보면 객체를 생성할때 데이터타입이 InterfaceA임 그래서
ia 는 funA() 메서드만 접근가능함

인터페이스는 작업명세서만 있는 껍데기
메서드의 정의는 그 인터페이스를 implements한 class에서 정의를 내린다

위의 사진은 1개클래스가 2개인터페이스를 이용하는건데
2개클래스가 1개 인터페이스를 이용하면서 인터페이스의 메서드를
오버라이드로 각각 재정의하면서 사용하기도 한다
그리고 메인클래스에서는 1개 인터페이스의 메서드들을 동작시킨다

인터페이스를 모른다고해서 프로그래밍을 못하는건 아니지만 코드가 깔끔해지고
더욱 유연한 사고를 가질 수 있으므로(?) 자바가 익숙해질 때 사용하려는 노력을 해보면
좋을 것 같다

------------------------------------------------------------------------------
추상클래스
클래스와 인터페이스의 특징들을 어느정도 가지고 있다

첫번째장
추상클래스는 엄밀히 따지자면 클래스이다.
extends를 이용한다
상위클래스로 추상클래스가 있고 인터페이스처럼 정의되어 있지 않으나(abstract 메서드)
abstract메서드는 상속한 클래스에서 정의를 내린다(인터페이스와 비슷)
선언만 되어있는 메서드를 갖기도 한다
일반 메서드를 가질 수 있다
멤버변수도 가질 수 있다



세번째장(인터페이스폴더 두번째사진)
class와 추상메서드로 사용할 메서드 앞에 abstract라는 키워드를 추가해준다
위코드 동작순서를 설명하기
Bank 추상클래스, MyBank 일반클래스(추상클래스를 상속받음)
메인클래스에서 MyBank 클래스를 객체로 선언할때 변수들이
MyBank 실행자로 들어가고 그것들이 super키워드를 통하여 상속해준 추상메서드의 변수들을 초기화시킨다
보면 MyBank에서 super로 Bank의 변수들을 초기화시키는중
installmentSavings와 cancellation메서드는 추상메서드 이기 때문에
상속받는 일반메서드에서 오버라이드가 필수적이다


abstract 클래스에서
abstract로 선언한 메서드는 꼭 일반 클래스에서 오버라이드해줘야한다.
공통된 부분은 추상메서드로 선언하고 추상클래스를 상속받은 클래스에서 알아서 재정의한다 라고 생각
(다형성)

네번째장(인터페이스폴더 두번째사진)
인터페이스와 추상클래스의 차이는 무엇이냐
일반적으로 추상클래스가 클래스의 기능까지 더 가지고 있어서 좋다고 하지만
각자의 장점이 갖는다

---------------------------------------
람다식
최근에 많이 사용하는 기법
처음엔 낯설지만 사용하다보면 많이 편리하다.

첫번째장
프로그래밍이
함수지향 -> 객체지향으로 오면서 구성이 탄탄해졌지만 코드가 복잡해짐
그래서 함수지향의 장점인 간단함을 이용하는 방법이 람다식이다.

기존에는 인터페이스를 만들고 객체를 이용하여 인터페이스 메서드를 구현했는데,
람다식은 인터페이스를 두고 인터페이스를 람다식을 이용하여 인터페이스 메서드를 구현
중간과정을 다 생략하고 핵심부분만 기술하는것(인터페이스 메서드에 변수를 받으면 변수를 명시한다던가 등)
(매개변수와 실행문만으로 작성한다)(접근자, 반환형, return 키워드 생략)
밑에서 여러 경우가있음
람다폴더 첫번째 사진

1. 매개변수가 1개이거나 타입이 같을 때, 타입을 생략할 수 있다
2. 실행문이 1개일 때, '{}'를 생략할 수 있다
3. 매개변수와 실행문이 1개일 때, '()'와 '{}'를 생략할 수 있다.
1,2,3은 두번째사진 ㄱㄱ

4. 매개변수가 없을때, '()'만 작성한다
세번째사진 ㄱㄱ

5. 반환값이 있는 경우
함수의 내용은 중간중간 초기화하면서 입맛대로 구현할 수 있다.
네번째사진 ㄱㄱ



-----------------------------------------
문자열 클래스

첫번째 장
초반에도 언급했지만 String은 자료형 타입이아닌 객체형 타입이다.
하지만 객체는 선언할때 타입 이름 = new 클래스()
이렇게 한다
String은 자바에서 많이 쓰이기에 new를 생략하는거다
그래서 String str = "JAVA"이렇게 선언한다
또한 첫번째 장에서 설명하는거는 메모리 구조인데
처음 JAVA라는 객체를 선언하고 JAVA에 _8을 더하면 기존에 있던 메모리에
추가되는것이 아니라 JAVA만 카피하여 JAVA_8이라는 새로운 메모리 또 그것을 가르키는
새로운 레퍼런스가 만들어지는것이다
그럼 기존에 있던 JAVA는 적절한 시점에 GC가 수거해간다.


두번째 장
그래서 스트링 객체는 속도를 약간 저해시키는 원인을 제공하는데 이를 보안하기위해
StringBuffer, StringBuilder를 사용한다

StringBuffer sf = new StringBuffer("JAVA"); 이렇게 기존에 선언을 하고 수정하고싶으면
sf.append("_8"); 이렇게 선언하면 
기존처럼 새로운 메모리 공간을 만드는것이 아닌 기존 메모리공간에 추가한다
append, insert, length, delete등 다양한 메서드가 존재한다

스트링버퍼와 스트링빌더는 사용방법은 거의 같으나
스트링버퍼의 단점을 보완한게 스트링빌더임 그래서 속도는 스프링 빌더가 조금 더 빠르다

데이터 안정성은 스트링버퍼가 좋은데
간단히 말하자면 메모리에 데이터가 들어가고 나가고 할때 순서대로 진행한다. 그럼 속도는
약간 느리지만 데이터가 훼손될 가능성이 낮다
스트링빌더는 그렇지않다
하지만 거의 똑같다고 보면되고 요즘에 많은 데이터를 요구할때는 스트링빌더를 선호한다

근데 그렇게 스트링 객체가 사람이 느낄 정도로 느린것은 아니지만
많은양의 데이터를 처리할때 차이가 있다는것

-----------------------------------------
Collections(자료형)

첫번째 장
어레이는 리스트의 범주중 가장 많이 사용하는 자료형이다
배열은 인덱스값을 활용하여 많은 데이터를 관리했다
리스트는 클래스가 아닌 인터페이스이고 이를 구현한 클래스는 인덱스를 이용해서 데이터를 괸리한다
(그리고 첫번째스샷 map이아니라 List임)
컬렉션폴더에 첫번째사진으로

ArrayList<데이터타입> 이름 = new 클래스<데이터타입>();
ArrayList라는 타입의 객체 선언

두번째 장
Map은 키를 활용하여 많은 데이터를 관리한다
Map또한 인터페이스로 이를 구현한 클래스는 Key를 이용하여 데이터를 활용한다.

HashMap이라는 클래스를 명시해줘야한다.
HashMap<Integer(키), String(밸류)> map = new HashMap<Integer(키), String(밸류)>();
두번째사진

이외에도 추가는 put, 교체는 덮어쓰고, 추출은 get(key), 제거는 remove(key), 
특정값 포함유무는 containsKey(key) 또는 containsValue(Value) 등 다양한 메서드가 존재한다.
 
----------------------------------------
예외처리

첫번째 장

프로그램 문제 즉, 예외로 인해 시스템 동작이 멈추는 것을 막기 위해 예외 처리를 한다

예외에서 에러는 개발자가 대처할 수 있음(코드상 연산처리 등)
에러에서 에러는 개발자가 대처할 수 없음(물리적)

예외는 Checked Exception과 Unchecked Exception 두가지로 나뉘어 있음
 Checked Exception 예외처리를 무조건 해야하고 하지 않는다면 컴파일조차 진행안함
Unchecked Exception의 예시로는 A/B에서 B가 0일경우 혹시 몰라서 개발자가 예외처리를 한다

두번째 장

Exception클래스는 무수히 많은 하위클래스를 가지고 있다

세번째 장
개발자가 처리할수있는 Unchecked Exception에서 많이 사용하는 구문이
try~catch, finally, throws구문이다.

Exception에는 다양한 클래스가 하위로 존재하는데 하나하나 에러구문을 매치하기 귀찮으면
Exception e처럼 최상위 클래스 한개만 사용해도 가능

다섯번째장
finally는 예외 발생 여부에 상관없이 이부분은 꼭 진행해야한다 할 때 사용함
예를 들면 외부에 있는 자원(DB 등)을 끌어다 쓸 때 끊는 작업을 해줘야하는데
그럴 때 finally를 사용함

여섯번째장
throws는 트라이캐치처럼 직접 해결하는게 아니라 자기를 호출한곳에 떠넘기는것
강의노트보면
메인이 퍼스트를부르고 퍼스트가 세컨 세컨이 써드를 부르는데 써드에서 예외가 발생
그리고 써드는 throws처리를 하였으니 여기서 예외가 발생하면 자기를 호출한곳으로
가진다
그럼 다시 역으로 타고 다시 처음부른 메인으로 간다

--------------------------------------------------------
입력과 출력(대충 요약했고 필요하면 구글링 ㄱㄱㄱ)
stream기법을 사용한다

두번째장
프로그램에서 입출력할때 Stream을 사용함(Stream은 추상클래스로 여러클래스를 가지고있음)

세번째장

read()는 1바이트 속도로 읽는다
매개변수로 byte[]를 줄 수 있는데 배열의 크기가 10바이트면 10바이트속도로 읽는다

wtire()는 매개변수가 좀 더 다양하다.
첫번째는 한번에 쓰기
두번째는 시작점과 그부터의 길이가 옵션으로 존재함

이것들을 실행할때는 예외처리로 진행해서 finally로 꼭 끊어주는 작업(Stream.close() 등)을 해줘야한다
이를 안할경우 에러발생함


------------------------------------------------------------
네트워킹

네트워크에 연결되어 있는 대상 사이에 데이터를 전송하는 방법

첫번째 장
InpustStream, OutputStream을 로컬이아닌 네트워크상에서 이루어지는것

두번째 장
대상 A,B가 네트워크에 연결되어 있는 상태에서 데이터를 주고받기 위해 도와주는 장치
예를 들면 친구집에다가 말을할때 소리지른다고 안들리기때문에 전화기를 사용하는데
여기서 전화기가 소켓을 의미함

세번째 장
자바에서는 친절하게 socket클래스를 제공해준다
데이터를 요청하는 클라이언트
또 데이터를 제공하는 서버

위에서 serverSocket = new ServerSocket(포트번호) ; 이렇게 자바는 
소켓의 클래스를 제공해줌(스트링처럼 앞에 자료타입을 명시할 필요없는거)

네트워킹 폴더 첫번째사진(서버소켓만든것)
클라이언트에서는 소켓 객체를 선언할 때
socket = new Socket( IP번호, 포트번호); 이렇게하면 끝




















 













