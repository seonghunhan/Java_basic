처음 시작할 때 
https://medium.com/duckuism/intellij%EC%97%90%EC%84%9C-eclipse-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-import-%ED%95%98%EA%B8%B0-9e222b5548db
참고해서 IDE에서 인텔리제이 와 이클립스 다루기(이거는 2019버전 인텔리제이)

- 인텔리제이를 사용한 이유
- 이클립스 파일을 인텔리제이에 가져온 이유
- 인텔리제이와 이클립스의 차이

https://www.jetbrains.com/help/idea/migrating-from-eclipse-to-intellij-idea.html#user_interface
인텔리제이 사이트에서 추천방법

https://willbesoon.tistory.com/191
이걸로 해결 (너카톡 본게임부터 시작)

배열

- 인덱스를 이용해서 자료형이 같은 데이터를 관리
- 배열을 구성하는 데이터의 자료형에 따라서 배열의 메모리 크기가 결정


- 배열도 변수와 마찬가지로 선언과 초기화 과정을 거쳐 사용
(배열 사용 후 초기화)
(배열 선언과 동시에 초기화)

- 배열 선언시 안에있는 변수의 타입은 미리 선언한걸로 넣어줘야함
- new라는 연산자를 이용해서 배열의 크기를 선언

위에 할 때 배열강의노트 밑에꺼 ㄱㄱ
(배열 선언 후 초기화)
public class helloworld {
    public static void main(String[] args) {

        int[] arr1 = new int[5]; // 배열 선언 단계
        arr1[0] = 100;
        arr1[1] = 200;
        arr1[2] = 300;
        arr1[3] = 400;
        arr1[4] = 500;

        System.out.println("arr[0] : " + arr1[0]);
        System.out.println("arr[1] : " + arr1[1]);
        System.out.println("arr[2] : " + arr1[2]);
    }
}

->
arr[0] : 100
arr[1] : 200
arr[2] : 300

(배열 선언과 동시에 초기화)
- 중괄호 사용 유의

public class helloworld {
    public static void main(String[] args) {

        int[] arr2 = {10, 20, 30}; // 배열 선언 단계

        System.out.println("arr[0] : " + arr2[0]);
        System.out.println("arr[1] : " + arr2[1]);
        System.out.println("arr[2] : " + arr2[2]);
    }
}


-> 
arr[0] : 10
arr[0] : 20
arr[0] : 30

* 어떤 언어는 배열의 크기를 동적으로 줄였다 늘렸다 하는 반면에 자바는 한번 선언할 때 크기가 정해지면 바뀔 수 없다
* 

---------------------
배열과메모리 강의노트 3번째장

배열 i(변수)의 주소는 첫번째 인덱스(10, i[0])의 메모리주소가 들어간다


배열 길이 함수부터 레퍼런스까지 강의노트4번째장 스샷 ㄱ

- 배열을 복사할 때 값들은 복사되지만 메모리는 같지 않다
- 배열1,2는 같기때문에 레퍼런스가 같음

다차원배열
-> 2차원까지는 사용하지만 3차원부터는 메모리를 많이 차지하기 때문에 잘 사용하지 않는다


-------------------------------------------------------

조건문 시작!!!!

양자택일 (주로 if)
다자택일 (주로 switch)

if(조건식)
조건문이 true일경우 실행
else if를 통해 다자택일도 가능


switch
비교대상이 되는 결과값과 선택사항이 많을 경우 주로 사용한다

위에꺼할때 인텔리제이 if클래스 실행

-----------------------------------------------------------
for, while, do while 시작!!!!


for (지역변수 ; 조건문 ; 증감){
	실행문
}

for문은 안에서 지역변수 i를 만들고 사용하지만
while은 밖에서 변수를 사용한다
- 조건문이 true이면 반복

do while은 조건 결과에 상관없이 최초한번은 무조건 실행

반복문 강의노트 복붙 ㄱㄱ

인텔리제이 forwhile도 ㄱㄱ



-----------------------------------------------------------------
객체 지향 프로그래밍이란???

프로그램에서의 객체는 눈에 보이지 않지만 하나의 기능들을 객체라고 부른다

객체를 만들기위한 틀을 클래스라고 한다
개발자들은 클래스만 만들고 필요에 따라 클래스를 뽑아 내는것
사용하지 않는 객체(누구와도 연동되지 않는)는 GC가(가비지 컬렉터) 회수한다
3페이지 파란 그랜저가 클래스임

------------------------------------------------------------------

클래스 제작과 객체 생성

클래스는 속성(멤버변수)와 기능(메서드) == 함수로 구성된다.


객체지향 프로그램을 만들어 놓으면 모듈화하여 다른곳에서 쉽게 사용할 수 있음

public 은 접근제한자인데 나중에 ㄱㄱ함

void는 반환값이 없다는것
반환값이 있고 그게 string형이다 그럼 메서드 앞에 string써야함
그리고 return으로 "~~~" 처럼 string을 써줘야함

외부에서 이 클래스를 이용해서 객체를 만들때 (스샷에 왼쪽이 객체를 만드는과정)(오른쪽이 클래스)
가장 먼저 호출받는게 생성자이고
생성자는 클래스와 이름이 같고, 반환형이 없다
생성자는 여러개 만들수도 있다
빈공간으로 놔두기도 한다

객체 3번째장 볼때 너카톡에 스샷찍어둔거 ㄱㄱ
new가 객체를 생성할 때 사용하는 명령어

두번째 스샷은 객체를 생성할때 파라메터도 주는것
그리고 적절한 생성자에 알아서 들어간다


---------------------------------------------------------------------

메서드

첫번 째 장

접근자 : 이 메서드의 접근을 어떻게하면 허용할지 안할지 결정한다
반환형 : 결과물을 호출부쪽으로 반환하는 것
	void는 반환값이 없다는 것
메서드 이름  : camel기법으로 첫문자는 소문자 그다음은 대문자로 표기
		동사를 먼저쓰고 다음은 명사로 쓰기



두번 째 장
필요시에만 사용한다


세번 째 장
중복메서드(같은 이름의 메서드)는 허용하지만 매개변수의 타입에서 차이가 있어야한다.


네번 째 장
접근자
public 외부에서 접근가능
private는 외부에서 접근 불가능하고 내부에서만 사용 가능


 
--------------------------------------------
객체와 메모리

첫번 째 장
객체는 메모리에서 동적으로 생성되고, 객체가 더 이상 필요 없게 되면 Gabage Collector가 삭제한다.

ObjectEx obj1 = new ObjectEx()
여기서는 obj1은 new라는 명령어를 통해 만든 객체 ObjectEx()를 가르키는 레퍼런스이다.

객체를 new라는 명령어를 통해 obj를 생성한다
ChildClass child(여기서 child는 레퍼런스이다(obj인 객체를 가르키는주소)) = new ChildClass()
위와 같은말임

obj를 가르키다가 쓸모가 없으면 노란색 obj처럼 레퍼런스가 없는 obj가 된다
(가비지 컬렉터가 관계가 안맺혀있는 obj는 쓸모없는 obj라고 판단하고 수거해간다)


두번 째 장
객체들이 같은 클래스를 선언하더라도 객체들의 레퍼런스는 엄연히 다르게 할당받는다


세번 째 장

네번 째 장
객체에 null을 대입하면 레퍼런스와 객체와의 관계가 끊기고 추후에 가비지컬렉터가 수거해간다
그러면 더이상 객체의 메서드와 속성을 접근할 수 없다.

-----------------------------------------------------
생성자와 소멸자 그리고 this 키워드

객체가 생성할때 생성하는 생성자가 있으면 GC가 호출할때 소멸시키는 소멸자도 있다

첫번째 장
클래스가 객체로 선언될 때 생성자를 먼저 호출하는데 만약 생성자가 없다면
컴파일 시점에 자동으로 만들어놔서 객체가 정상적으로 선언될 수 있다.

두번째 장

세번째 장
obj4에 두번 객체를 선언할경우 첫번째 객체와의 관계는 끊기는데,
finaize는 저런게 있다라고만 알고 넘어가기
객체가 소멸될 때 선언된다

나중에 알아서 gc가 제거하지만
System.gc()메서드를 사용하면
좀 더 빨리 해줄래?라고 요청하는것 (그렇다고 바로 GC가 작동하지는 않는다)


네번째 장
카톡 스샷 ㄱㄱ

-----------------------------------------------------
패키지와 static

첫번째 장

패키지는 클래스를 효율적으로 관리하기 위함

패키지 이름은 개발자 마음대로 정한다
일반적으로 첫번째 장에 따라 작명한다

클래스를 만들때 가장 상단에 그 파일이 소속되어있는 패키지를 적는다
ex) 
package com.java.employee;

public class Employee {

}

반대로 다른 패키지에있는 클래스를 객체로 선언할 때는
상단에 import로 해당 클래스의 패키지를 명시해주고 객체를 선언한다
ex)
package com.java.employee;

import com.java.dailyJournal.DailyJournal;
(import com.java.dailyJournal.*; 이렇게 하면 dailyJournal패키지 안에 클래스를 모두 import한것)

public class Employee {
	
	DailyJournal journal = new DailyJournal();
	
}


세번 째 장
static 카톡스샷 ㄱㄱ
다같이 공유하면서 쓰는 변수다 라고 생각하기

EmployeeBank 클래스에 static으로 mount라는 변수를 선언했고 
왼쪽 메인함수에서 parkBank, leeBank로 객체를 선언하고 mount를 둘 다 이용할때
공유가 가능하다 
기존에 박찬호가 100을 저축하고 이승엽이 300을 저축하니까
amount는 400이 나온것
근데 너무 많이 static으로 처리하면 메모리에 부담되니깐 적절하게 사용하기
-------------------------------------------------------
데이터 은닉
데이터의 속성(public같은거)으로 인하여 외부의 변질을 막기 위해서 사용
그래서 보통 private로 만들어서 외부로부터 변질되지 않게 사용함


첫번 째 장
위의 내용 ㄱㄱ

두번 째 장
private로 설정하면 외부에서 영영 접근이 불가능하니깐
그것을 메서드로 통해서 접근할 수 있게 만드는 것

이거 자바공부폴더 ㄱㄱ
1번째 사진에서는 처음 private로 선언된 변수에 최초 입력을 하는경우인거고

그런 private로 선언된 변수를 바꾸고 싶을때 set을 이용해서 외부에서 Doris로 바꾸는 과정을 뜻함

------------------------------------
상속

상위 클래스로부터 특정한 속성과 기능을 상속받는다

첫번 째 장

두번 째 장
상속을 하는 이유

세번 째 장
상속 구현하는 방법 (상속폴더 첫번째 캡쳐참고) (extends 이용)
childclass에서는 cfildFun과 상위클래스의 parentFun메서드까지 이용할 수 있다

결과물을 보면 ChildClass constructor(생성자)가 실행되기전에 상위 클래스의 ParentClass constructor가 실행되었음
이는 상속받는 클래스보다 상위 클래스가 먼저 실행된다는것을 의미한다

자바언어에서는 상속을할때 단일상속만 지원한다.
상속은 객체지향에서 나온 기법인데, 다른언어에서는 다중상속을 지원하기도 한다
예를 들면
ChildClass extend 옆에 여러개의 클래스를 명시하면 다중상속임
한 클래스 뿐 아니라 여러 클래스에서 상속을 받는 것!

네번 째 장
상위 클래스의 모든 자원을 이용할 수 있지만, private 접근자의 속성과 메서드는 사용할 수 없다.

다이어그램을 만들 때 아래(아들)에서 위(부모)쪽으로 실선 화살표로 만든다


------------------------------
상속 특징

위는 상속의 기본 개념 및 구현이였고 여기는 상속에 대해 좀 더 자세히 ㄱㄱ

첫번째 장
상위 클래스의 있는 기능을 재정의해서 사용하는 것을 메서드 오버라이드라고 한다
ChildClass에서 ParentClass의 메서드를 이용할 때 makeJJajang을 오버라이드 하면서
more dilecious가 붙여서 나온것
그리고 위에 @Override를 붙여주는게 약속

두번째 장
데이터 타입
객체를 선언할때

A b = new A() 에서 첫번째 A가 class에서 데이터타입이라고 정의함
그럼 배열을 이용할 수 있음 -> 객체 타입이 다 똑같기 때문


폴더 안에 사진(두번째캡쳐)에서 Mainclass의 ParentClass[]가 여기 객체의 타입이 되는 것!

네번째장

this는 내 객체안의 변수를 가르키고 super를 이용하면 최상위클래스의 변수를 가르킨다.

--------------------------------------
내부 클래스와 익명 클래스

첫번 째 장

내부 클래스는 클래스 안에 또 다른 클래스를 선언하는 것
보통은 클래스안에 생성자 다음 메서드를 표기하는데 여기서는 클래스를 한번 더 선언하는 것
두 클래스의 멤버에 쉽게 접근할 수 있다
근데 로직이 복잡해 보여서 실무에서는 잘 사용하지 않는다.


두번 째 장
익명클래스는 인터페이스나 추상클래스에서 주로 사용한다.

폴더에 네번째캡쳐ㄱㄱㄱㄱ

-------------------------------------------------------
인터페이스
클래스와 외형으로는 비슷하지만 클래스처럼 객체를 생성한다든지 메서드를 호출해서 기능을 수행하거나 할 수 없다
인터페이스를 사용한다면 좀 더 구조가 단단하고 세련된 코드를 짤 수 있다.
객체가 다양한 자료형(타입)을 가질 수 있기에 인터페이스를 사용한다


첫번째장
클래스에서 인터페이스를 구현하는 과정을 거친다.
그리고 클래스에서 객체를 생성하는 과정을 거친다



세번째장
애초에 src에서 new로 생성할 때 class가 아닌 Interface가 따로 있음
Interface에서는 매서드를 선언만할 수 있고 정의할수는 없음
그래서 Interface는 작업명세서라고 부르기도 한다
원래는 public void funA()하고 중괄호 {
} 여기에 정의를하는데 Interface에서는 그런것을 할 수 없다.
그러면 선언한 메서드는 누가 구현을하느냐
인터페이스를 구현해내는 클래스에서 새롭게 정의를 내려서 사용한다.

인터페이스B만들고 10분10초부터 시작






 













